.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.04)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Clair::Index 3pm"
.TH Clair::Index 3pm "2012-07-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
package Clair::Index
Creates various indexes from supplied Clair::GenericDoc objects.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\s-1JB\s0 Kim
jbremnant@gmail.com
20070407
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This is the module that builds positional inverted index for documents.
The inverted index uses the terms in the document as the \*(L"key\*(R" for looking
up documents that contain them. Once the index is built, it can be used for
various \s-1IR\s0 purposes. To build the index, you require the following calls:
.PP
.Vb 1
\&        use Clair::Index;
\&        
\&        my $idx = new Clair::Index(DEBUG => $DEBUG, stop_word_list => $stop_word_list);
\&        
\&        my $gdoc = new Clair::GenericDoc( DEBUG => $DEBUG, content => "/some/doc");
\&
\&        $idx\->insert($gdoc);
\&  
\&        ... insert more ...
\&
\&        $idx\->build();
.Ve
.PP
By default, it will choose \*(L"mldbm\*(R" to store the constructed index hashes. 
if you want to store the index into a different format / layout, you need to
implement a sub-module under \fB\f(CB$self\fB\-\fR{rw_modules_root}> (defaults to ./Index),
and then specify \fB\f(CB$self\fB\-\fR{index_file_format}>. For example:
.PP
.Vb 5
\&        my $idx = new Clair::Index(
\&                DEBUG => $DEBUG,
\&                stop_word_list => $stop_word_list
\&                index_file_format => "your_module_name",
\&        );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This package also uses runtime loaded sub-modules to implement index writing 
and reading. The index writing should take the perl hash structure and layout
the contents in the file system in module-specific way. Similarly, the index
reading should make it transparent to the \s-1API\s0 user on how the index content is
read from the filesystem.
.PP
See \fB./Index/mldbm.pm\fR for example.
.PP
This Index.pm module also supports a list of stop words when constructing the index.
In case the list of file containing stop words is supplied, all the words that
appear in that list will be excluded from the index construction.
.PP
The inverted index is created from extracted content from Clair::GenericDoc objects. 
The document_id is assigned with auto-increment counter, and the positions of 
each stemmed word will be registered for each document in the index. Thus, this
module implements the construction of full positional inverted index.
.SS "new"
.IX Subsection "new"
.Vb 1
\& The constructor understands the following significant hash key\-values:
.Ve
.IP "index_root \- creates the index files into this specified directory." 8
.IX Item "index_root - creates the index files into this specified directory."
.PD 0
.IP "stop_word_list \- path to a file containing the list of stop words." 8
.IX Item "stop_word_list - path to a file containing the list of stop words."
.IP "rw_modules_root \- path to where sub-modules are contained." 8
.IX Item "rw_modules_root - path to where sub-modules are contained."
.IP "index_file_format \- specify the name of the module you want to use for index r/w." 8
.IX Item "index_file_format - specify the name of the module you want to use for index r/w."
.IP "stem_docs \- causes all Clair::GenericDoc object content to be stemmed." 8
.IX Item "stem_docs - causes all Clair::GenericDoc object content to be stemmed."
.PD
.PP
.Vb 1
\& Most of the constructor keys specified above has defaults.
.Ve
.SS "insert"
.IX Subsection "insert"
.Vb 3
\& Takes the instantiated Clair::GenericDoc objects and stores them into the internal
\& array. It ensures that you are passing in the object that is blessed with the
\& Clair::GenericDoc name.
\&
\& The internal array of Clair::GenericDoc objects is later used to construct various index
\& hashes.
.Ve
.SS "build"
.IX Subsection "build"
.Vb 3
\& This subroutine loops through the B<$self\->{documents}> array, and for each
\& registered Clair::GenericDoc object, it extracts the content and passes it to 
\& a private subroutine called B<$self\->_add_to_index()>.
.Ve
.SS "_add_to_index"
.IX Subsection "_add_to_index"
.Vb 3
\& This subroutine where the actual index construction happens. For each
\& subdocument returned by the extract function of Clair::GenericDoc object,
\& it takes the contents and builds the internal hash structure. 
\&
\& The internal hash structures are:
.Ve
.IP "inverted_index \- our major index that contains positional info on words." 8
.IX Item "inverted_index - our major index that contains positional info on words."
.PD 0
.IP "document_meta_index \- contains meta data for each doc, such as title, etc.." 8
.IX Item "document_meta_index - contains meta data for each doc, such as title, etc.."
.IP "document_index \- it's a regular index (opposite of inverted)" 8
.IX Item "document_index - it's a regular index (opposite of inverted)"
.IP "word_index \- index containing the word frequency. (probably redundant, and yes it is)" 8
.IX Item "word_index - index containing the word frequency. (probably redundant, and yes it is)"
.PD
.PP
.Vb 2
\& The document id as well as the token positions are auto\-incremented 
\& integers.
\&
\& This method supports incremetal update to the index. If the
.Ve
.SS "clean"
.IX Subsection "clean"
.Vb 1
\& Cleans out the index directory specified under B<$self\->{index_root}>.
.Ve
.SS "sync"
.IX Subsection "sync"
.Vb 3
\& Simple wrapper around index_write, which in turn will call submodule 
\& implementation of index writing. After the index has been written, it
\& will save the current_doc_id in order to support incremental index writing.
.Ve
.SS "init"
.IX Subsection "init"
.Vb 3
\& Initializes a number of indexes by means of sub\-module index_read call.
\& The specified index file is fetched from disk and mapped into an internal
\& hash structure.
\&
\& This is how you can take the contents on disk and read them into memory
\& to speed up your queries later on.
.Ve
.SS "index_write"
.IX Subsection "index_write"
.Vb 3
\& A wrapper function that loads a submodule at runtime and passes the $self
\& object to the underlying submodule routine that implements the actual 
\& writing to disk.
.Ve
.SS "index_read"
.IX Subsection "index_read"
.Vb 5
\& A wrapper function that loads a submodule at runtime and reads 
\& the necessary indexed files. The returned value is a hash.
\& There is a third parameter that acts as a boolean flag that tells
\& the submodules whether you are reading in a meta index or a regular
\& inverted index.
.Ve
.SS "_load_rw_module"
.IX Subsection "_load_rw_module"
.Vb 2
\& A privation function that loads the necessary index R/W modules
\& at runtime.
.Ve
.SH "TODO"
.IX Header "TODO"
.Vb 1
\& Write more submodules to output different index file layout.
.Ve
