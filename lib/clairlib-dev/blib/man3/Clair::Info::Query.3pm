.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.04)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Clair::Info::Query 3pm"
.TH Clair::Info::Query 3pm "2012-07-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
package Clair::Info::Query
A module that implements different types of queries.
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\s-1JB\s0 Kim
jbremnant@gmail.com
20070407
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module contains bulk of the query retrieval algorithm using the inverted index.
At the core, it initializes the necessary indexes from the Index.pm object, 
and keeps the perl hash data structures in memory for query processing.
if the instantiated Index.pm object is not supplied in the constructor, it will
attempt to instantiate it.
.PP
The constructor initializes these three indexes by default (can be overriden):
.IP "document_index, document_meta_index" 8
.IX Item "document_index, document_meta_index"
.PP
The significant flags for constructor are:
.IP "required_indexes \- an array reference containing the names of indexes to initialize." 8
.IX Item "required_indexes - an array reference containing the names of indexes to initialize."
.PD 0
.IP "default_query_logic \- defaults to fuzzy_or_merge, this is the name of the subroutine." 8
.IX Item "default_query_logic - defaults to fuzzy_or_merge, this is the name of the subroutine."
.PD
.PP
Once the Clair::Info::Query object is instantiated, various queries are possible. For example:
.PP
.Vb 1
\&        use Clair::Info::Query;
\&  
\&        my $q = Clair::Info::Query(DEBUG => $DEBUG);
\&
\&        $tokens_string = \*(Aq"juliet romeo"\*(Aq;
\&        my $output = $q\->process_query($tokens_string);
\&        $output = $q\->document_frequency("juliet")\*(Aq,
\&        $output = $q\->words_frequency("romeo")\*(Aq,
.Ve
.PP
Where, \f(CW$output\fR variable contains either ARRAY-ref or the HASH-ref of results.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
while some query functions can be taken off of this module and placed elsewhere, this module
implement standard query retrieval functions from inverted index. One highlight of this 
module is the fact that it supports N\-gram tokens (phrases) search.
.SS "new"
.IX Subsection "new"
.Vb 3
\& The constructor. It instantiates the Clair::Index.pm object by default and initializes 
\& various meta indexes, except the inverted index. The inverted index gets dynamically
\& loaded on\-demand, depending on the query.
.Ve
.SS "normalize_input"
.IX Subsection "normalize_input"
.Vb 4
\& Just a wrapper around the real subroutine implemented under StringManip package.
\& Also, if the index is created without the stop_words, the query string should
\& also omit the stop words. The stop word list is supplied the same way as it did
\& on Clair/Index.pm, via the constructor.
.Ve
.SS "process_query"
.IX Subsection "process_query"
.Vb 3
\& This subroutine is the entry point for "normal" query strings. Multi\-word phrase
\& queries are supported, as well as negation of the query using various private
\& routines.
\&
\& The only required input parameter is the actual query string supplied by the user.
\& The output is either a reference to an array or a reference to a hash, which can
\& be specified by a second boolean input parameter.
.Ve
.SS "result_logic"
.IX Subsection "result_logic"
.Vb 3
\& Again, a wrapper subroutine that runs one of the underlying subroutines
\& that operate on returned result set from the query. The default query
\& result set processing is "fuzzy or" logic.
.Ve
.SS "fuzzy_or_merge"
.IX Subsection "fuzzy_or_merge"
.Vb 5
\& Implements "fuzzy or" logic by returning all documents pertaining to query
\& tokens. A very rudimentary document scoring is done by simply counting the
\& number of times a particular token occurs in the document. The counting uses
\& the number of existing positions recorded in the second tier of the inverted
\& hash.
.Ve
.SS "_load_index_for_word"
.IX Subsection "_load_index_for_word"
.Vb 4
\& This function is used to load a chunk of of the entire inverted index on
\& demand. The segmentation of the index is dependent on the Index/<format>.pm
\& sub\-module. Thus, we blindely trust the subset of the inverted index returned
\& by the call B<index_read> within Index.pm module.
\&
\& The actual word being searched is passed into the method. The underlying 
\& index submodule should have a corresponding index_read function that takes
\& care of returning the appropriate data in a hash.
.Ve
.SS "_return_doc_for_token"
.IX Subsection "_return_doc_for_token"
.Vb 3
\& This subroutine, by default, handles combinations of single word queries. If it 
\& encounters query token containing phrases, it will run another private subroutine
\& B<_return_doc_for_ngram> to handle it.
\&
\& The input parameters are 1) the query token (single word or phrase), 2) the associated
\& subset of inverted index, 3) and a boolean flag indicating whether it\*(Aqs a negation
\& or not.
\&
\& The return value is a hash reference containing the document id\*(Aqs and their 
\& scores.
.Ve
.SS "_return_doc_for_ngram"
.IX Subsection "_return_doc_for_ngram"
.Vb 2
\& This private routine does several things to narrow down and speed up our 
\& n\-gram (phrase) search. Here is the flow of the algorithm:
\& 
\& 1) checks if all the words in the phrase are found in the inverted index\-es.
\&    If not all words are found, it simply returns an empty hash ref.
\&
\& 2) determines the word that has the least frequency in the given phrase.
\&
\& 3) retrieves the list of documents for the least frequent word.
\&
\& 4) finds the "lowest common denominator" list of documents that intersect
\&    for all words in the phrase. If no intersecting documents are found,
\&    it simply returns an empty hash ref.
\&
\& 5) passes the common list of documents and their associated indexes to
\&    another private subroutine called B<_match_word_positions>. This private
\&    subroutine resolves the positional dependency among the list of words.
.Ve
.SS "_match_word_positions"
.IX Subsection "_match_word_positions"
.Vb 3
\& This subroutine has the heart of the n\-gram match algorithm. The input parameters
\& are 1) list of words in the phrase (ordered), and 2) documents that are common
\& for all the words in the phrase.
\&
\& The algorithm for determining the phrase existency is relatively simple.
\& Since the positions for the words in the phrase have to be all next to one another,
\& the offset between each word is just 1.
\&
\& Thus, by anchoring all the preceding words against the position of the last word
\& in the phrase, you can determine the relative offset that a word in the phrase will
\& have against the last word in the phrase. For example, consider this phrase:
\&
\&          "jbkim likes search engine class" 
\& 
\&  index:     0     1     2      3     4
\&  offset:    4     3     2      1     0
\&
\& By adding the index for each word against the offset, the matching documents will 
\& have a value of "4" for all words in the phrase. From there, we simply count the
\& documents that satisfy this condition. This subroutine implements the algorithem
\& exactly as described above.
.Ve
.SS "term_frequency"
.IX Subsection "term_frequency"
.Vb 1
\& Given user input, returns the number of time a particular term occurs in a document.
.Ve
.SS "words_frequency"
.IX Subsection "words_frequency"
.Vb 2
\& Given user input, either a single term or a phrase, determines the number of times the queried string
\& appears in the entire index.
.Ve
.SS "document_frequency"
.IX Subsection "document_frequency"
.Vb 2
\& Given user input, either a single term or a phrase, returns the number of documents
\& containing it.
.Ve
.SS "document_title"
.IX Subsection "document_title"
.Vb 1
\& Given a document ID, returns the document title.
.Ve
.SS "document_content"
.IX Subsection "document_content"
.Vb 1
\& Given a document ID, returns the document content, either stemmed or unstemmed.
.Ve
.SS "_document_info"
.IX Subsection "_document_info"
.Vb 1
\& A private subroutine that actually looks up the doc meta data against the document_meta_index.
.Ve
