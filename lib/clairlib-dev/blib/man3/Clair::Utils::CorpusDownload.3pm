.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.04)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Clair::Utils::CorpusDownload 3pm"
.TH Clair::Utils::CorpusDownload 3pm "2012-07-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CorpusDownload
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
CorpusDownload
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module supplies the functionality of a subset of the
perltree routines.  Specifically, it downloads the documents
requested, stores them in the \s-1TREC\s0 corpus format used by
perltree and builds the \s-1TF/IDF\s0 databases.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
\&\f(CW$cref\fR = Clair::Utils::CorpusDownload::new(rootdir => \*(L"/path/to/project\*(R",
  corpusname = \*(L"uiuc\*(R");
.PP
\&\fBrootdir\fR
.PP
(optional) The path to the directory where the corpus
and associated \s-1TFIDF\s0 will be built and stored.  Default is
\&\*(L"/data0/projects/tfidf\*(R".  This path should be an absolute
path, not a relative one.
.PP
\&\fBcorpusname\fR
.PP
(required) The name of the corpus that will be built.
The corpus will consist of all documents with URLs in
the array \f(CW@urls\fR that can be located at build time.
The top level of the corpus will be named
\&\f(CW$rootdir\fR/$corpusname.
.PP
\&\fBbuildCorpus\fR
.PP
\&\f(CW$cref\fR\->buildCorpus(urlref => \e@urls, cleanup => 0);
.PP
Builds a new corpus consisting of all documents at the URLs
passed in parameter \f(CW@urls\fR.
.PP
\&\fBurlref\fR
.PP
(required) A reference to an array of URLs from which the
corpus should be built.
.PP
\&\fBcleanup\fR
.PP
(optional) Remove (default) or retain (parameter 0 passed) metafiles
produced during corpus build.  (Note:  Retaining the metafiles can produce
undesirable side-effects during a rebuild.)
.SS "buildIdf"
.IX Subsection "buildIdf"
\&\f(CW$cref\fR\->buildIdf(stemmed => 0, punc => 0);
.PP
Builds the \s-1IDF\s0.  The \s-1IDF\s0 entries are stemmed or not depending on the
parameter passed to the constructor. Punctuation is included depending on
the punc argument.
.PP
\&\fBstemmed\fR
.PP
(optional) Set to 1 if the \s-1IDF\s0 elements should be stemmed,
and 0 otherwise.  Default is 0 (not stemmed).
.PP
\&\fBpunc\fR
.PP
(optional) Set to 1 to include punctuation. Default is 0.
.SS "build_docno_dbm"
.IX Subsection "build_docno_dbm"
\&\f(CW$cref\fR\->\fIbuild_docno_dbm()\fR;
.PP
Builds the DOCNO-to-URL and URL-to-DOCNO database.  The details
of this will be explained in the .pdf file that will be available
soon from the \s-1CLAIR\s0 website.  Meanwhile, all the user needs to
know is this method must be called before either \s-1TF\s0 is built.
.SS "buildTf"
.IX Subsection "buildTf"
\&\f(CW$cref\fR\->buildTf(stemmed => 1);
.PP
Builds the \s-1TF\s0.  The \s-1TF\s0 entries are stemmed or not depending on
the parameter passed to the constructor.
.PP
Note that build_docno_dbm must have been called before this.
.PP
\&\fBstemmed\fR
.PP
(optional) Set to 1 if the \s-1IDF\s0 elements should be stemmed,
and 0 otherwise.  Default is 0 (not stemmed).
.PP
\&\fB\s-1NOTE\s0\fR
.PP
If both stemmed and unstemmed TFs are desired, there is no need
to rebuild the docno dbm prior to building the second \s-1TF\s0.
.PP
Using of the \s-1TF\s0 and \s-1IDF\s0 once they are built is described in Tf.pm
and Idf.pm
.SS "makeDirs"
.IX Subsection "makeDirs"
(private) makes directory tree for corpus
.SS "wgetall2"
.IX Subsection "wgetall2"
(private) downloads documents from \s-1URLS\s0 in {urlsref}, using
\&\s-1GNU\s0 wget
.SS ""
.IX Subsection ""
(private) identify failed, duplicate and empty downloads
.SS "getUniqList"
.IX Subsection "getUniqList"
(private) compile list of unique downloads
.SS "cleanup"
.IX Subsection "cleanup"
(private) remove metafiles
.SS "urlsToCorpus"
.IX Subsection "urlsToCorpus"
(private) build corpus in \s-1TREC\s0 format from downloaded documents
.SS "process_document_text"
.IX Subsection "process_document_text"
(private) split text into words and store words in hash
.SS "build_term_counts"
.IX Subsection "build_term_counts"
token_counts
.PP
Returns an array of term counts in the corpus
.PP
This is used by the synth corpus tools
.SS "build_doc_len_dist"
.IX Subsection "build_doc_len_dist"
build_doc_len_dist
.PP
Build the document length file
.SS "get_doc_len_dist"
.IX Subsection "get_doc_len_dist"
\&\fIget_doc_len_dist()\fR
.PP
Gets the document length distribution.  Returns a hash with each key
being a document length, and the values being the number of documents with
that length
.SS "get_term_counts"
.IX Subsection "get_term_counts"
\&\fIget_term_counts()\fR
.PP
Gets the term counts.  Returns a hash with each key being a term/token
and the corresponding value the number of occurences of that term in the
collection.
