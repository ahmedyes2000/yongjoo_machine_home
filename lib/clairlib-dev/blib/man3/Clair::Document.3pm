.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.04)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Clair::Document 3pm"
.TH Clair::Document 3pm "2012-07-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Clair::Document \- Document Class for the CLAIR Library
.SH "VERSION"
.IX Header "VERSION"
Version 1.02
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
This module is one of the core modules for the \s-1CLAIR\s0 library.  The Document
holds all of of the text of a file.  Different operations such as stemming,
stripping html, word counting, among others can be performed on a Document.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
\&\f(CW$docref\fR = new Clair::Document(string => 'Document text', type => 'text', id => 'doc' class => 'label');
.PP
Creates a new document from a filename or string and assigns it the specified
class label. First argument is either \*(L"string\*(R" or \*(L"file\*(R" to identify which
method will be used.  If \*(L"string\*(R" is used then the second argument should be
a string representing the full text or html content of the file.  If \*(L"file\*(R"
is used then the second argument should be the filename to be used for input.
The filename for a \*(L"string\*(R" input is undefined.  Use '\fIset_filename()\fR' to define
this parameter.
.SS "count_words"
.IX Subsection "count_words"
Counts the number of words contained within the text of the document.  In order
to use properly first instantiate a Document object with a file or a string, then
call this method on it.
.SS "print"
.IX Subsection "print"
Prints the contents of Document to standard output
.SS "save"
.IX Subsection "save"
.Vb 1
\&        save(file => \*(Aqout.txt\*(Aq, type => \*(Aqtext\*(Aq)
.Ve
.PP
Saves the contents of Document to a file.
.SS "strip_html"
.IX Subsection "strip_html"
Removes all tags from html of Document.  Resulting string is saved as the text
of Document, then returned.
.SS "get_sent"
.IX Subsection "get_sent"
Depricated. Use get_sentences instead. Returns sentences of the document
.SS "get_sentences"
.IX Subsection "get_sentences"
Returns the sentences of the document.
.SS "get_id"
.IX Subsection "get_id"
Returns the id of Document
.SS "get_class"
.IX Subsection "get_class"
\&\f(CW$class\fR = \f(CW$docref\fR\->\fIget_class()\fR
.PP
Returns the class label of Document (for use in text classification).
.SS "get_parent_document"
.IX Subsection "get_parent_document"
Returns the parent document of the document. Used if the document is a sentence
or line taken from another document to allow backtracking to the original document.
.SS "set_parent_document"
.IX Subsection "set_parent_document"
Sets the parent document of the document. Used if the document is a sentence or
line taken from another document to allow backtracking to the original document.
.SS "split_into_words"
.IX Subsection "split_into_words"
Returns the list of words in the document.  Defaults to the text of the document
but can be set to stem or html by passing an optional type argument: split_into_words(type => 'stem')
.SS "get_unique_words(type => 'stem')"
.IX Subsection "get_unique_words(type => 'stem')"
Returns a list of unique words in the document. Defaults to extracting these
words from the the stemmed version of the document, but can be set to text or
html by passing an optional type argument: get_unique_words(type => 'stem')
.SS "set_id"
.IX Subsection "set_id"
.Vb 1
\&        set_id(id => \*(Aqnew_id\*(Aq)
.Ve
.PP
Sets the id of Document.
.SS "set_class"
.IX Subsection "set_class"
.Vb 1
\&        $docref\->set_class(\*(Aqlabel\*(Aq)
.Ve
.PP
Sets the class label of Document.
.SS "get_xml"
.IX Subsection "get_xml"
Returns the xml value of a document.
.SS "get_text"
.IX Subsection "get_text"
Returns the text value of a document.
.SS "get_html"
.IX Subsection "get_html"
Returns the html value of a document.
.SS "get_stem"
.IX Subsection "get_stem"
Returns the stemmed version of the Document. If the text has not already been
stemmed, it will first call \fIstem()\fR and then save and return the results.
.SS "stem"
.IX Subsection "stem"
Stems the Document text
.SS "stem_keep_newlines"
.IX Subsection "stem_keep_newlines"
Stems the document, but without removing the newlines.  This is needed by some
methods to track where a word came from or to treat lines individually.  Saves
the result as the stemmed version of the document, then returns it
.SS "split_into_lines"
.IX Subsection "split_into_lines"
Splits the document into an array at newlines
.SS "split_into_sentences"
.IX Subsection "split_into_sentences"
Splits the document into an array of sentences (uses Text::Sentence to split the
document) (A future version will allow the user to specify via lib/Clair/Config.pm
whether they'd prefer to use MxTerminator over Text::Sentence.)
.SS "filter_sentences"
.IX Subsection "filter_sentences"
.Vb 2
\&        filter_sentences( matches => "regex" )
\&        filter_sentences( test => $sub )
.Ve
.PP
Applies a filter to the sentences in this document and returns a new Clair::Document
containing the sentences that passed the filter. The filter can either be a
regular expression (with the matches parameter) or a subroutine references
(with the test parameter). The id of the new document will be the same as the
original document (if the original id is defined).
.SS "xml_to_text"
.IX Subsection "xml_to_text"
Converts an \s-1XML\s0 document to text.
.SS "tf"
.IX Subsection "tf"
.Vb 1
\&        tf( type => "stem" )
.Ve
.PP
Splits the document into terms of the given type, then returns a hash containing
the term frequencies.
.SS "sentence_count"
.IX Subsection "sentence_count"
Returns the total number of sentences in this document.
.SS "sentence_index_in_range($i)"
.IX Subsection "sentence_index_in_range($i)"
Returns true of there is a sentence with index \f(CW$i\fR, false otherwise. Sentence
indexing starts at 0.
.ie n .SS "set_sentence_feature($i, %features)"
.el .SS "set_sentence_feature($i, \f(CW%features\fP)"
.IX Subsection "set_sentence_feature($i, %features)"
Sets the given features for sentence with index \f(CW$i\fR. Returns undef if \f(CW$i\fR insn't
in the sentence range or if no features are given. Otherwise returns the number
of features added to the given sentence. \f(CW%features\fR should be a hash mapping names
to values. For example, set_sentence_feature(1, f1 => 1, f2 => 0.5, f3 => \*(L"red\*(R")
sets those features to the second sentence.
.SS "get_sentence_features($i)"
.IX Subsection "get_sentence_features($i)"
Returns a hash mapping the feature names to values of the given sentence.
Returns undef if the sentence index is out of range.
.ie n .SS "get_sentence_feature($i, $name)"
.el .SS "get_sentence_feature($i, \f(CW$name\fP)"
.IX Subsection "get_sentence_feature($i, $name)"
Returns the value of the given feature for the given sentence. Returns undef if
the index is out of range or if the feature isn't defined for the sentence.
.SS "\fIremove_sentence_features()\fP"
.IX Subsection "remove_sentence_features()"
Removes all features from every sentence.
.ie n .SS "remove_sentence_feature($i, $name)"
.el .SS "remove_sentence_feature($i, \f(CW$name\fP)"
.IX Subsection "remove_sentence_feature($i, $name)"
Removes the given feature from the given sentence. Returns true if succesfully
removed, returns undef otherwise.
.ie n .SS "compute_sentence_features( f1 => $subref1, f2 => $subref2, ... )"
.el .SS "compute_sentence_features( f1 => \f(CW$subref1\fP, f2 => \f(CW$subref2\fP, ... )"
.IX Subsection "compute_sentence_features( f1 => $subref1, f2 => $subref2, ... )"
Computes the specified features for each sentence in the document by calling
\&\f(CW$self\fR\->compute_sentence_feature(fN => \f(CW$subrefN\fR) for each feature.
.ie n .SS "compute_sentence_feature( name => $name, feature => $subref, normalize => 1 )"
.el .SS "compute_sentence_feature( name => \f(CW$name\fP, feature => \f(CW$subref\fP, normalize => 1 )"
.IX Subsection "compute_sentence_feature( name => $name, feature => $subref, normalize => 1 )"
Computes the given feature for each sentence in the document. The feature
parameter should be a reference to a subroutine. The subroutine will be called with the following parameters defined:
.IP "\(bu" 8
document \- A reference to the document object
.IP "\(bu" 8
sentence \- The sentence text
.IP "\(bu" 8
sentence_index \- The index of the sentence
.IP "\(bu" 8
state \- A hash reference that is kept in memory between calls to the
subroutine. This lets \f(CW$subref\fR save precomputed values or keep track of inter-sentence
relationships.
.PP
A feature subroutine should return a value. Any exceptions thrown by the feature
subroutine will be caught and a warning will be shown. If a feature subroutine
returns an undefined value, the feature will not be set and awarning will be shown.
This method returns undef if either name or feature are not defined.
.PP
The normalize parameter, if set to a true value, will scale the values of this
feature so that the minimum value is 0 and the maximum value is 1. Nothing will
happen if any of the feature values are non-numeric.
.SS "normalize_sentence_features(@names)"
.IX Subsection "normalize_sentence_features(@names)"
Scales the given features so that the minimum value is 0 and the maximum value
is 1 for each feature.
.SS "normalize_sentence_feature($name)"
.IX Subsection "normalize_sentence_feature($name)"
Scales the values of the given feature so that the minimum value is 0 and the
maximum value is 1. Nothing will happen if any of the feature values are non-numeric.
.ie n .SS "compute_sentence_features( %features );"
.el .SS "compute_sentence_features( \f(CW%features\fP );"
.IX Subsection "compute_sentence_features( %features );"
Computes a set of features on each sentence. \f(CW%features\fR should be a hash mapping
names to sub references. See compute_sentence_feature for more information.
.SS "get_sentence_score($i)"
.IX Subsection "get_sentence_score($i)"
Returns the score of the sentence with index \f(CW$i\fR. Returns undef if \f(CW$i\fR is out of
range or if the score has not been defined yet.
.SS "\fIget_sentence_scores()\fP"
.IX Subsection "get_sentence_scores()"
Returns an array of the sentence scores. If the scores haven't been set, returns
undef.
.ie n .SS "set_sentence_score($i, $score)"
.el .SS "set_sentence_score($i, \f(CW$score\fP)"
.IX Subsection "set_sentence_score($i, $score)"
Sets the score of the sentence with the given index. Returns undef if \f(CW$i\fR is out
of range or if \f(CW$score\fR is undef. Otherwise returns 1.
.SS "normalize_sentence_scores"
.IX Subsection "normalize_sentence_scores"
Scales the scores of the sentences so that the max score is 1 and the min score
is 1. If the max score is equal to the min score, then all of the scores are set
to 1. If the scores are undefined, then returns undef. Otherwise, returns 1.
.SS "score_sentences"
.IX Subsection "score_sentences"
.Vb 1
\&        score_sentences( combiner => $subref, normalize => 0, weights => \e%weights )
.Ve
.PP
Scores the sentences using the given combiner. A combiner subroutine will be
passed a hash comtaining feature names mapped to values and should return a real
number. By default, the sentence scores will be normalized unless normalize is set
to 0. If the combiner does not return an appropriate value for each sentence,
score_sentences returns undef and the sentence scores are left uncomputed.
.PP
Alternatively, if a hash reference is specified for the parameter weights, then
the returned score will be a linear combination of the features specified in
weights according to their given weights. This option will override the combiner
parameter.
.SS "sentence_scores_computed"
.IX Subsection "sentence_scores_computed"
Returns true if each sentence has a score, false otherwise.
.SS "set_document_feature"
.IX Subsection "set_document_feature"
.Vb 1
\&        $docref\->set_document_feature(%features)
.Ve
.PP
Sets the specified features for the document. Returns undef if no features are given.
Otherwise returns the number of features added to the document. \f(CW%features\fR should
be a hash mapping feature names to values. For example,
set_document_feature(f1 => 1, f2 => 0.5, f3 => \*(L"red\*(R") sets those features for the document.
.SS "\fIget_document_features()\fP"
.IX Subsection "get_document_features()"
.Vb 1
\&        $features = $docref\->get_document_features()
.Ve
.PP
Returns a hash mapping the document's feature names to values.
.SS "get_document_feature($name)"
.IX Subsection "get_document_feature($name)"
.Vb 1
\&        $val = $docref\->get_document_feature($name)
.Ve
.PP
Returns the value of the given feature for the document. Returns undef if the
feature isn't defined for the document.
.SS "remove_document_features"
.IX Subsection "remove_document_features"
.Vb 1
\&        $docref\->remove_document_features()
.Ve
.PP
Removes all features from the document.
.SS "remove_document_feature"
.IX Subsection "remove_document_feature"
.Vb 1
\&        $docref\->remove_document_feature($name)
.Ve
.PP
Removes the given feature from the document Returns true if succesfully removed,
returns undef otherwise.
.SS "compute_document_features"
.IX Subsection "compute_document_features"
.Vb 1
\&        $docref\->compute_document_features( f1 => $subref1, f2 => $subref2, ... )
.Ve
.PP
Computes the specified features for the document by calling
\&\f(CW$self\fR\->compute_document_feature(fN => \f(CW$subrefN\fR) for each feature.
.SS "compute_document_feature"
.IX Subsection "compute_document_feature"
.Vb 1
\&        compute_document_feature( name => $name, feature => $subref );
.Ve
.PP
Computes the given feature for the document. The feature parameter should be
a reference to a subroutine. The subroutine will be called with the following
parameter defined:
.IP "\(bu" 8
document \- A reference to the document object
.PP
A feature subroutine should return a value. Any exceptions thrown by the feature
subroutine will be caught and a warning will be shown. If a feature subroutine
returns an undefined value, the feature will not be set and a warning will be shown.
This method returns undef if either name or feature are not defined.
.SS "get_summary"
.IX Subsection "get_summary"
.Vb 1
\&        get_summary( size => 10, preserve_order => 0 )
.Ve
.PP
Returns a summary of this document based on the sentence scores. If the scores
haven't been computed, returns undef. A summary is an array of hash references.
Each hash reference represents a sentence and contains the following key/value pairs:
.IP "\(bu" 8
index \- The index of this sentence (starting at 0).
.IP "\(bu" 8
text \- The text of this sentence.
.IP "\(bu" 8
features \- A hash reference of this sentence's features.
.IP "\(bu" 8
score \- The score of this sentence.
.PP
The size parameter to this method sets the maximum length of the summary in number
of sentences. The preserve_order parameter controls how the sentences are ordered.
If preserve_order is set to 0, then the sentences will be returned in descending
order by score. If preserve_order is set to a true value (or undefined), the original
order of the sentences from the document will be preserved. preserve_order => 1 is
 the default behavior.
.PP
Here is an example of the object returned by this method:
.PP
\&\f(CW@summary\fR = (
{ index => 0,
text => \*(L"Roses are red.\*(R",
features => { has_flower => 1, position => 1 },
score => 1 },
{ index => 2,
text => \*(L"Sugar is sweet.\*(R",
features => {has_flower => 0, position => 0.5 },
score => 0.75 }
);
.SS "is_numeric_feature"
.IX Subsection "is_numeric_feature"
.Vb 1
\&        is_numeric_feature($name)
.Ve
.PP
Returns true if the given feature has a numeric value for all sentences.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dagitses, Michael << <clair at umich.edu> >>
Radev, Dragomir << <radev at umich.edu> >>
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-clair\-document at rt.cpan.org\*(C'\fR,
or through the web interface at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=clairlib\-dev <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=clairlib-dev>.
I will be notified, and then you will automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
perldoc Clair::Document
.PP
You can also look for information at:
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
http://annocpan.org/dist/clairlib\-dev <http://annocpan.org/dist/clairlib-dev>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
http://cpanratings.perl.org/d/clairlib\-dev <http://cpanratings.perl.org/d/clairlib-dev>
.IP "\(bu" 4
\&\s-1RT:\s0 \s-1CPAN\s0's request tracker
.Sp
http://rt.cpan.org/NoAuth/Bugs.html?Dist=clairlib\-dev <http://rt.cpan.org/NoAuth/Bugs.html?Dist=clairlib-dev>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
http://search.cpan.org/dist/clairlib\-dev <http://search.cpan.org/dist/clairlib-dev>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2006 The University of Michigan, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it  under
the same terms as Perl itself.
