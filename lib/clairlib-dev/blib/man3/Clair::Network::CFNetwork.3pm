.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.04)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Clair::Network::CFNetwork 3pm"
.TH Clair::Network::CFNetwork 3pm "2012-07-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Clair::Network::CFNetwork
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
CFNetwork is a subclass of the Clair::Network. It includes the extra functionality needed to perform community finding within weighted, undirected networks. The main community finding algorithm is an implementation of the algorithm described in: A. Clauset, M. E. J. Newman and C. Moore, \*(L"Finding Community Structure in Very Large Networks,\*(R" Phys. Rev. E. 70, 066111 (2004).
.SH "Description"
.IX Header "Description"
CFNetwork is a subclass of the Clair::Network. It includes the extra functionality needed to perform community finding within weighted, undirected networks. The main community finding algorithm is an implementation of the algorithm described in: A. Clauset, M. E. J. Newman and C. Moore, \*(L"Finding Community Structure in Very Large Networks,\*(R" Phys. Rev. E. 70, 066111 (2004).
.SH "METHODS"
.IX Header "METHODS"
.SS "calc_k"
.IX Subsection "calc_k"
.Vb 1
\&    $k = $cfn\->calc_k($u)
.Ve
.PP
For a given node, returns the sum of the weights of all the edges connected to it.
.SS "getM"
.IX Subsection "getM"
.Vb 1
\&    $m = $cfn\->getM
.Ve
.PP
Returns the sum of all the edge weights in the graph.
.SS "isConnected"
.IX Subsection "isConnected"
.Vb 1
\&    if ( $cfn\->isConnected ) { ... }
.Ve
.PP
Returns true if the CFNetwork is connected, false otherwise. May take some time on larger networks.
.SS "new"
.IX Subsection "new"
.Vb 2
\&    my $cfn = Clair::Network::CFNetwork\->new()
\&    my $cfn = Clair::Network::CFNetwork\->new(name => "Network_Name")
.Ve
.PP
Constructor for CFNetwork class objects. Creates an empty network. If name is specified, it will be used as the network name; the default name is \*(L"CFNetwork\*(R". The network name will be used as a prefix for certain output files; ideally it should not include spaces.
.SS "add_edge"
.IX Subsection "add_edge"
.Vb 1
\&    $cfn\->add_edge($u,$v)
.Ve
.PP
Adds a new edge to the network, but gives a default weight of 1. Prevents creation of self-edges.
.SS "remove_node"
.IX Subsection "remove_node"
.Vb 1
\&    $cfn\->remove_node($id)
.Ve
.PP
This is essentially the same as the Network::remove_node function, except that it updates the value of m associated with this network in addition to deleting the node.  This is necessary in order to maintain a valid m value in the presence of node deletions. A running m tally is faster and easier then trying to calculate m everywhere it is needed, especially for larger networks.
.SS "add_weighted_edge"
.IX Subsection "add_weighted_edge"
.Vb 1
\&    $cfn\->add_weighted_edge($u,$v,$weight)
.Ve
.PP
Adds a new edge to the network, with the given weight. Prevents creation of self-edges. If the edge specified already exists in the network, its new weight is the sum of the old and \f(CW$weight\fR. However, if this new weight is negative, the edge is removed from the network completely. In this way, a network of non-negative, non-self edges can be maintained, and the weights can be easily incremented/decremented with this function. This function returns the new weight of the edge, or 0 if the new weight would be negative or if the edge specified was a self-edge. This routine also updates the m value associated with this network (that is, the sum of the weights of all edges in the network).
.SS "remove_edge"
.IX Subsection "remove_edge"
.Vb 1
\&    $cfn\->remove_edge($u,$v)
.Ve
.PP
This is essentially the same as the Network::remove_edge function, except that it updates the value of m associated with this network in addition to deleting the edge.  This is necessary in order to maintain a valid m value in the presence of edge deletions. A running m tally is faster and easier then trying to calculate m everywhere it is needed, especially for larger networks.
.SS "communityFind"
.IX Subsection "communityFind"
.Vb 3
\&    $cfn\->communityFind()
\&    $cfn\->communityFind(skip_connection_test => 0);
\&    $cfn\->communityFind(dirname => $dirname)
.Ve
.PP
The community finding algorithm. Writes the series of joins to the \*(L"$cfn\->{name}.joins\*(R"; writes the optimal node labeling to the \*(L"$cfn\->{name}.bestComm\*(R". The format of the .joins file is  (x y c Q) for each line, where:
.PP
.Vb 4
\&    x = (label of community that grows)
\&    y = (label of community that is absorbed)
\&    c = (number of communities remaining)
\&    Q = (Q value after the join).
.Ve
.PP
The format of .bestComm file is one node and its label per line.
.PP
This function also produces a file \*(L"$cfn\->{name}.mljoins\*(R", which is a version of the .joins file that has been formatted so that it can be plotted using the Matlab \fIdendrogram()\fR function. Since this Matlab function fails if the node ids are non-sequential or contain an id of zero, new node ids are needed; therefore, the node ids in this file will be different from the ids in the .joins file and in the source data. The dendrogram can be plotted in Matlab using the supplied plotDendro.m file; an appropriate labelfile for the Matlab function is also generated by \fIcommunityFind()\fR, by calling \fIprintNodeLabels()\fR.
.PP
This routine calls _initialize, _join, and (for debugging) _printInternals.
.PP
Note that \fIcommunityFind()\fR expects that the network is connected, and, by default, will abort with an error message otherwise. To determine whether the network is connected, the function calls the \fIGraph::is_connected()\fR function prior to doing anything. However, for large graphs, this can be an expensive operation. This check can be turned off by setting the parameter variable skip_connection_test to 1 \*(-- in this case, the check will not be performed, and the algorithm will continue forward. Only turn off the connection test if you know the network is fully connected and wish to avoid the overhead of checking again; otherwise errors will occur.
.PP
To find communities within the connected components of the network, use getConnectedComponent to generate sub-CFNetworks from those connected components, and then run \fIcommunityFind()\fR on those sub-CFNetworks.
.PP
This function returns the value of the highest Q value achieved during the community merging, or 0 if the input graph was non-connected.
.PP
If dirname is given, this will be location the files are written to.  If it is not given, the files will be written to the current working directory.
.SS "getConnectedComponent"
.IX Subsection "getConnectedComponent"
.Vb 1
\&    my $subCFNetwork = $cfn\->getConnectedComponent($num)
.Ve
.PP
This routine builds a new CFNetwork, consisting of the nodes and edges of the \f(CW$num\fR\-th largest connected component of the original CFNetwork. For example, if \f(CW$num\fR == 2, the output will be a reference to a new CFNetwork object, with nodes identical to those in the 2nd largest connected component of the original, and all their internal edges.
.PP
The labels and values of nodes are perserved, as are the edge weights. The name associated with the new CFNetwork is the old name, suffixed with \*(L".$num\*(R".
.PP
If \f(CW$num\fR is greater than the number of connected components, the returned network will  consist of the smallest connected component of the original. If \f(CW$num\fR is less than 1, the returned network will be the largest connected component of the original.
.PP
This function allows large, non-connected networks to be broken into pieces that can be analyzed by \fIcommunityFind()\fR. Since the components are not connected, nodes in different components cannot be part of the same community structure.
.SS "printNodeLabels"
.IX Subsection "printNodeLabels"
.Vb 1
\&    $cfn\->printNodeLabels($filename);
.Ve
.PP
This prints to filename a list of all the node labels in the graph, one per line. The labels are sorted by node id. If a node has no label, its label is listed as \*(L"undef\*(R".
.PP
This routine is useful when feeding node labels to a dendrogram drawing function.
.SS "printNodeValues"
.IX Subsection "printNodeValues"
.Vb 1
\&    $cfn\->printNodeValues($filename);
.Ve
.PP
This prints to filename a list of all the node values in the graph, one per line. The values are sorted by node id. If a node has no value, its value is listed as \*(L"undef\*(R".
.SS "printEdgeWeights"
.IX Subsection "printEdgeWeights"
.Vb 1
\&    $cfn\->printEdgeWeights($filename);
.Ve
.PP
This prints to filename a list of all the edges and their weights in the graph, one per line. The format is \*(L"source target weight\*(R". The weights are sorted by the source node id.
.SS "_initialize"
.IX Subsection "_initialize"
.Vb 1
\&    ($QR,$aR,$HR,$HM) = $cfn\->initialize;
.Ve
.PP
Internal subroutine; there is no need for a user to call this routine, as it is only needed within the community finding algorithm. Initializes modularity table for community finding algorithm. Also calculates supporting information.
.PP
\&\f(CW$QR\fR is a reference to a hash of refernences to hashes; basically, each hash stored in \f(CW$QR\fR contains the positive Delta Q_i_j values of the modularity table.
\&\f(CW$aR\fR is a hash reference; it stores the a_i values for each node.
\&\f(CW$HR\fR is a hash reference; \f(CW$HR\fR\->{$i} is the node index for which delta Q is highest, given \f(CW$i\fR.
\&\f(CW$HM\fR is an array reference; the first element is the highest delta Q value in the table. The second element and third elements are the ($i,$j) location of that value.
.SS "buildFromMatrixFile"
.IX Subsection "buildFromMatrixFile"
.Vb 1
\&    $cfn\->buildFromMatrixFile($filename,$ignoreweights)
.Ve
.PP
This routine will read a symmetric adjacency matrix from a file and add those edges to the existing graph, creating nodes where necessary. If an edge between two nodes already exists, the weight in the matrix file will be added to the edge weight.
.PP
If \f(CW$ignoreweights\fR is set to true, than the actual added weight for every edge will be 1, regardless of the matrix values. This allows the construction of an idential graph with uniform (1) weights.
.PP
The matrix file should contain only the adjacency matrix, 1 row per line, with elements separated with whitespace. The matrix is assumed to be symmetric.
.SS "_join"
.IX Subsection "_join"
.Vb 1
\&    $self\->_join($i,$j,$QR,$aR,$HR,$HM);
.Ve
.PP
The procedure that joins two communities; here, \f(CW$i\fR is absorbed by \f(CW$j\fR. Also updates \f(CW$QR\fR, \f(CW$aR\fR, \f(CW$HR\fR, and \f(CW$HM\fR to reflect the change. This procedure should only be used internally, within \fIcommunityFind()\fR.
.SS "_printInternals"
.IX Subsection "_printInternals"
.Vb 1
\&    $self\->_printInternals($QR,$aR,$HR,$HM);
.Ve
.PP
This is a debugging procedure that prints to standard output the contents of the given variables in a somewhat-readable fashion. It should not be used.
.SS "numConnectedComponents"
.IX Subsection "numConnectedComponents"
.Vb 1
\&    $self\->numConnectedComponents
.Ve
.PP
Returns the number of connected components in the network. Can be time consuming for larger networks.
.SS "export2PajekProject"
.IX Subsection "export2PajekProject"
.Vb 2
\&    $self\->export2PajekProject(partition => $partition)
\&    $self\->export2PajekProject(partition => $partition, dirname => $dirname)
.Ve
.PP
Creates a Pajek-formatted file representing the network. \f(CW$partition\fR
can either be \*(L"best\*(R", in which case the Pajek file will include a
partition that labels vertices according to the .bestComm file, or a
number. If \f(CW$partition\fR is a number, the Pajek file will include a
partition that divides the network into that many communities.
.PP
\&\f(CW$dirname\fR is the location of the .bestComm and .join files, as well as
the location to which the output file will be written. If \f(CW$dirname\fR
isn't given, the location to read and write from is the location the
current working directory.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ryan Roth << rmr48 \s-1AT\s0 columbia dot edu >>
.SH "BUGS"
.IX Header "BUGS"
None Known.
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2007 Ryan Roth, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.
.SS "readFromPajek read pajek's .net file in and build the network"
.IX Subsection "readFromPajek read pajek's .net file in and build the network"
\&\f(CW$network\fR\->readFromPajek(\*(L"/data0/projects/cltest/CFNetwork/SampsonL.net\*(R");
