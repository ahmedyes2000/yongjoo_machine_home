.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.04)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Clair::GenericDoc 3pm"
.TH Clair::GenericDoc 3pm "2012-07-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 2
\& B<package> Clair::GenericDoc
\& A class to standardize and create generic representation of documents.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 3
\& JB Kim
\& jbremnant@gmail.com
\& 20070407
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& This module is designed to take in any text\-oriented document and parse
\& it based on its MIME type. The parsing is made modular by the use of 
\& sub\-modules which will be dynamically loaded at runtime. 
\&
\& Furthermore, the document is converted into perl hash representation
\& and can be dumped to disk in XML format.
\&
\& Once you instantiate the object, all you have to do is to invoke one
\& subroutine to take parsing to effect:
\&  
\&  use Clair::GenericDoc;
\&
\&  my $gdoc = new Clair::GenericDoc(content => "/path/to/your/file", stem => 1);
\&  my $hash = $gdoc\->extract();
\&
\& This module is an alternate interface to Clair::Document. Whereas 
\& Clair::Document focuses on extracting information out of documents, this
\& interface focuses on parsing and its modularity.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 2
\& The module will try to do the "smart thing" and determine the file type 
\& for you. You can force feed the parsing sub\-module:
\&
\&  my $gdoc = new Clair::GenericDoc(
\&   content => "/path/to/your/file",
\&   stem => 1,
\&   use_parser_module => shakespear.pm,
\&  );
\&
\& Assuming that "shakespear.pm" exists under B<./GenericDoc> sub\-directory.
\&
\& There are other features of this module which will be covered in the 
\& method specifications.
.Ve
.SS "new"
.IX Subsection "new"
.Vb 2
\& The constructor. Most of the internal flags are overriden.
\& The significant ones are:
.Ve
.ie n .IP "cast \- a boolean flag that will ""cast"" the object to Clair::Document object." 4
.el .IP "cast \- a boolean flag that will ``cast'' the object to Clair::Document object." 4
.IX Item "cast - a boolean flag that will cast the object to Clair::Document object."
.PD 0
.IP "content \- either path to a file, or the actual string." 4
.IX Item "content - either path to a file, or the actual string."
.IP "module_root \- specify the directory for the submodules." 4
.IX Item "module_root - specify the directory for the submodules."
.IP "xml_outputdir \- specify the directory to dump the hash into xml file." 4
.IX Item "xml_outputdir - specify the directory to dump the hash into xml file."
.IP "use_parser_module \- hardcode the parser module, which bypasses auto file type detection." 4
.IX Item "use_parser_module - hardcode the parser module, which bypasses auto file type detection."
.IP "stem \- do stemming." 4
.IX Item "stem - do stemming."
.IP "strip \- strip meta characters." 4
.IX Item "strip - strip meta characters."
.PD
.SS "newcast"
.IX Subsection "newcast"
.Vb 2
\& This function understands how to create Clair::Document from arguments passed in
\& via this constructor.
.Ve
.SS "makestr"
.IX Subsection "makestr"
.Vb 2
\& If the supplied "content" is a file, it slurps in the content and converts it
\& into a string. 
\&
\& TODO: make this portion more modular to operate on urls and other content types
\&       such as gzip\-ed/tar\-ed files.
.Ve
.SS "document_type"
.IX Subsection "document_type"
.Vb 2
\& Determines the mime content type from a file or a string, and
\& returns the content type token.
.Ve
.SS "load_parser"
.IX Subsection "load_parser"
.Vb 4
\& After the content/document type is determined, this subroutine tries
\& to use the appropriate sub\-module. Obviously, if the sub\-module to handle
\& the content is not available, this subroutine will exit gracefully after
\& printing the reason via B<$self\->errmsg()>.
.Ve
.SS "_determine_module"
.IX Subsection "_determine_module"
.Vb 5
\& This subroutine takes the mime type string and tries to match up an
\& appropriate sub\-module in the $self\->{module_root} directory. It does
\& so by listing the available modules under that dir and then match 
\& the substring of the $type parameter passed in against the name of 
\& the sub\-module. 
\&
\& When creating a parser sub\-module, one should be conscious of the 
\& name he/she picks for that module. In case $self\->{use_parser_module}
\& exists, it blindedly returns that module to be later loaded.
.Ve
.SS "extract"
.IX Subsection "extract"
.Vb 5
\& This is the wrapper for other crucial routines that determine the content type and 
\& runtime loading of the necessary parser sub\-module. Once the runtime loading of the
\& sub\-module is successful, it runs the functions called B<extract()> within it \- overloading
\& of the subroutine name. The parsing logic is entirely upon the B<extract()> subroutine
\& within the loaded sub\-module.
\&
\& The content returned should be a reference to an array containing hash items. Thus, each
\& document/content provided in GenericDoc can manifest into multiple, subdivided documents.
\&
\& The returned content, then, will be stripped of metacharacters and stemmed, based on the
\& constructor flags.
\&
\& Finally, the required hash keys within the returned data structure is:
.Ve
.ie n .IP "$hash\->{parsed_content}" 4
.el .IP "\f(CW$hash\fR\->{parsed_content}" 4
.IX Item "$hash->{parsed_content}"
.PD 0
.ie n .IP "$hash\->{title}" 4
.el .IP "\f(CW$hash\fR\->{title}" 4
.IX Item "$hash->{title}"
.ie n .IP "$hash\->{path}" 4
.el .IP "\f(CW$hash\fR\->{path}" 4
.IX Item "$hash->{path}"
.PD
.PP
.Vb 1
\& More on the convention used for sub\-modules later.
.Ve
.SS "_validate_extracted_hash_content"
.IX Subsection "_validate_extracted_hash_content"
.Vb 2
\& NOTE: unimplemented yet. Should take care of validating the data structure returned by
\&       the sub\-module.
.Ve
.SS "to_xml"
.IX Subsection "to_xml"
.Vb 1
\& Takes a hash and converts it into xaml string.
.Ve
.SS "from_xml"
.IX Subsection "from_xml"
.Vb 1
\& Takes an xml string or file and converts it back to a perl hash.
.Ve
.SS "save_xml"
.IX Subsection "save_xml"
.Vb 3
\& Simply dumps the xml string into a file. It makes sure that the subdirectory
\& specified in $self\->{xml_outputdir} is created before the file is written
\& to disk.
.Ve
.SS "morph"
.IX Subsection "morph"
.Vb 6
\& Morph the existing object into Clair::Document object. This subroutine serves as
\& both convenience and compatibility functions. This function works after you\*(Aqve
\& instantiated the Clair::Genericdoc object and all the proper constructor parameters
\& have been initialized. The extract() function is invoked to parse the content, and
\& then subsequently the Clair::Document will be constructed with necessary fields
\& pre\-populated.
.Ve
.SH "TODOS"
.IX Header "TODOS"
.IP "Make the subroutine \fBmakestr\fR more modular" 4
.IX Item "Make the subroutine makestr more modular"
Right now, it only does file to string conversion. It should auto-magically
do url-download to string conversion as well.
.IP "Make the mime type determination a bit more robust" 4
.IX Item "Make the mime type determination a bit more robust"
Sometimes mime-types don't come back as expected. Search for other ways to
determine the filetypes and the associated submodules more bullet proof.
