.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.04)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Clair::Network 3pm"
.TH Clair::Network 3pm "2012-07-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Clair::Network \- Network Class for the CLAIR Library
.PP
head1 VERSION
.PP
Version 0.01
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
The Network Class is one of the core modules for the \s-1CLAIR\s0 library.  The Network described a structure
of relationships between nodes, and has operations for performing many typical graph functions, such as
finding the diameter of the graph, adding and removing normal and external nodes, and creating edges.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
\&\f(CW$network\fR = new \fIClair::Network()\fR;
.PP
Creates a new, empty network
.SS "add_node"
.IX Subsection "add_node"
add_node($id, \f(CW$text\fR)
.PP
Adds a vertex to the graph.  Vertex has attribute text set to \f(CW$text\fR
.SS "remove_node"
.IX Subsection "remove_node"
remove_node($id)
.PP
Removes the vertex with id \f(CW$id\fR from the graph
.SS "add_edge"
.IX Subsection "add_edge"
add_edge($id1, \f(CW$id2\fR);
.PP
Creates an edge between the two vertices specified.  If a vertex is not already part
of the graph, it is automatically added.
.SS "remove_edge"
.IX Subsection "remove_edge"
remove_edge($u, \f(CW$v\fR)
.PP
Removes the edge from \f(CW$u\fR to \f(CW$v\fR from the graph.
.SS "set_node_weight"
.IX Subsection "set_node_weight"
set_node_weight($id, \f(CW$weight\fR)
.PP
Set the weight of node \f(CW$id\fR.
.SS "get_node_weight"
.IX Subsection "get_node_weight"
get_node_weight($id)
.PP
Returns the weight of the specified vertex.
.SS "find_path"
.IX Subsection "find_path"
\&\f(CW@path\fR = find_path($s, \f(CW$v\fR)
.PP
Finds the shortest path from \f(CW$s\fR to \f(CW$v\fR using the Floyed Warshall algorithm.
.SS "compute_cohesion"
.IX Subsection "compute_cohesion"
compute_cohesion
.PP
Computes the cohesion of the documents in the network.
.SS "export_to_Pajek"
.IX Subsection "export_to_Pajek"
export_to_Pajek($networkName, \f(CW$filename\fR)
.PP
Write the network to the file \f(CW$filename\fR in Pajek form, giving it the specified network name.
.SS "num_documents"
.IX Subsection "num_documents"
num_documents
.PP
Returns the number of documents in the network
.SS "num_pairs"
.IX Subsection "num_pairs"
num_pairs
.PP
Returns the number of pairs of documents, defined as nd * (nd \- 1) / 2 where nd is the number
of documents.
.SS "num_links"
.IX Subsection "num_links"
num_links
.PP
Returns the number of links (edges) in the network.  If the parameter external is specified
and set to 1 (or internal is specified and set to 0), the number of external links is returned,
otherwise the number of internal links is given.  If the parameter unique is specified and equal
to 1, only unique links will be counted.
.SS "compute_in_link_histogram"
.IX Subsection "compute_in_link_histogram"
\&\fIcompute_in_link_histogram()\fR
.PP
Returns a histogram of the number of inlinks per node in the network
.SS "avg_in_degree"
.IX Subsection "avg_in_degree"
\&\fIavg_in_degree()\fR
.PP
Returns the average number of inlinks per node in the network
.SS "compute_out_link_histogram"
.IX Subsection "compute_out_link_histogram"
\&\fIcompute_out_link_histogram()\fR
.PP
Returns a histogram of the number of outlinks per node in the network
.SS "avg_out_degree"
.IX Subsection "avg_out_degree"
\&\fIavg_out_degree()\fR
.PP
Returns the average number of outlinks per node in the network
.SS "compute_total_link_histogram"
.IX Subsection "compute_total_link_histogram"
\&\fIcompute_total_link_histogram()\fR
.PP
Returns a histogram of the number of links (both out and in) per node in the network
.SS "avg_total_degree"
.IX Subsection "avg_total_degree"
\&\fIavg_total_degree()\fR
.PP
Returns the average number of links (both out and in) per node in the network
.SS "power_law_exponent"
.IX Subsection "power_law_exponent"
power_law_exponent($histogram_reference)
.PP
Computes the power law coefficient on the histogram passed in by reference.
This uses linear regression on the logs of the data points to find both the
coefficient and the exponent.
.PP
Retun value is a string of the form \*(L"y = a x^b\*(R" where a is the coefficient and
b is the exponent.
.SS "newman_power_law_exponent"
.IX Subsection "newman_power_law_exponent"
newman_power_law_exponent($histogram_reference, \f(CW$x_cutoff\fR)
.PP
Computes the power law exponent on the histogram passed in by reference.
This uses the method described in Newman\e's \*(L"Power laws, Pareto distributions
and Zipf's law\*(R", formula 5 and 6.
.PP
Return value is an array containing two items, the power law exponent, and a
measure of the statistical error
.SS "power_law_out_link_distribution"
.IX Subsection "power_law_out_link_distribution"
\&\fIpower_law_out_link_distribution()\fR
.PP
Returns the power law formula from the out link distribution
.SS "power_law_in_link_distribution"
.IX Subsection "power_law_in_link_distribution"
\&\fIpower_law_in_link_distribution()\fR
.PP
Returns the power law formula from the in link distribution
.SS "power_law_total_link_distribution"
.IX Subsection "power_law_total_link_distribution"
\&\fIpower_law_total_link_distribution()\fR
.PP
Returns the power law formula from the total link distribution
(both in and out links)
.SS "diameter"
.IX Subsection "diameter"
diameter(filename => \f(CW$filename\fR, directed => 1, max => 0)
.PP
Returns the diameter of the network.  If the parameter 'directed' is 1
or not specified, this is the diameter of the directed network.  If it
is 0 or the parameter 'undirected' is 1, then this is the diameter of
the undirected network.  If max is 1 or not specified, then this is the
maximum diameter.  If max is 0 or avg is 1, then this is the average diameter.
.PP
A filename may also be specified to produce debugging information while
the diameter is being determined.
.SS "average_shortest_path"
.IX Subsection "average_shortest_path"
\&\fIaverage_shortest_path()\fR
.PP
Finds the average shortest path of a graph.  The average shortest path is the
average of all of the shortest paths between pairs of vertices.  To compute
this, we loop through each vertex, computing the shortest paths to all vertices
that vertex reaches.  The average of that vertex is then computed.  This is
repeated for all vertices with greater than zero out-degree in the graph, and
the average of that is returned.
.SS "write_links"
.IX Subsection "write_links"
write_links($filename, skip_duplicates => 1, transpose => 1, weights => 0)
.PP
Writes the network links to a file.  If the parameter skip_duplicates
is specified as 1, duplicate edges are skipped.  If the parameter
transpose is 1, the links are written transposed.
.SS "write_nodes"
.IX Subsection "write_nodes"
write_nodes($filename)
.PP
Writes the list of nodes in the network to a file.
.SS "Watts_Strogatz_clus_coeff"
.IX Subsection "Watts_Strogatz_clus_coeff"
Watts_Strogatz_clus_coeff(filename => \f(CW$filename\fR)
.PP
Computes the Watts Strogatz clustering coefficient.  If a
filename is provided, intermediate output is written to
the file.
.SS "write_db"
.IX Subsection "write_db"
write_db($filename, transpose => 1)
.PP
Writes the graph's links to a db file.  Links are written
transposed if the parameter transpose is provided and
equal to 1.
.SS "dfs_visit_1"
.IX Subsection "dfs_visit_1"
An internal function used by find_scc
.SS "iterative_dfs_visit_1"
.IX Subsection "iterative_dfs_visit_1"
An internal function used by find_scc
.SS "iterative_dfs_visit_1_v2"
.IX Subsection "iterative_dfs_visit_1_v2"
An internal function used by find_scc
.SS "dfs_visit_2"
.IX Subsection "dfs_visit_2"
An internal function used by find_scc
.SS "iterative_dfs_visit_2"
.IX Subsection "iterative_dfs_visit_2"
An internal function used by find_scc
.SS "iterative_dfs_visit_2_v2"
.IX Subsection "iterative_dfs_visit_2_v2"
An internal function used by find_scc
.SS "find_scc"
.IX Subsection "find_scc"
find_scc($dbfile, \f(CW$xpfile\fR, \f(CW$finfile\fR)
\&\f(CW$dbfile\fR should be the filename of a db file of the links
that will be used by find_scc (the file can be produced
with write_db)
\&\f(CW$xpfile\fR should be the filename of a db file of the links
tranposed
\&\f(CW$finfile\fR is the location where a temporary file should go
that will be used by find_scc and the helper functions
.PP
find_scc finds a strongly connected subgraph from the graph
of the network.  It needs to input files, a db file of the
links and a db file of the transposed links.
.SS "find_largest_component"
.IX Subsection "find_largest_component"
find_largest_component($type)
.PP
type is the type of component, either \*(L"weakly\*(R" or \*(L"strongly\*(R"
.PP
Finds the largest component in a graph, returning a network made up of that
component.
.SS "write_link_matlab"
.IX Subsection "write_link_matlab"
write_link_matlab($histogram_reference, \f(CW$filename\fR, \f(CW$dependency\fR)
.PP
Writes a Matlab for the histogram.  \f(CW$histogram_reference\fR should
be a reference to the histogram that should be written to the
matlab file.  \f(CW$dependency\fR is the names of any dependencies that
the Matlab file should have
.SS "write_link_dist"
.IX Subsection "write_link_dist"
write_link_dist($histogram_reference, \f(CW$filename\fR)
.PP
Writes a link distribution file for the histogram that is passed in
by reference
.SS "average_cosines"
.IX Subsection "average_cosines"
($linked_avg, \f(CW$not_linked_avg\fR) = average_cosines($cosine_matrix_reference)
.PP
Returns the average of the cosines between documents that are connected
in the matrix and between documents that are not connected.  The averages
are returned in an array.
.SS "get_index"
.IX Subsection "get_index"
An internal function used by cosine_histograms.  Used to determine
what bin a cosine value should go into.
.SS "cosine_histograms"
.IX Subsection "cosine_histograms"
cosine_histograms($cosine_matrix_reference)
.PP
Returns a histograms for cosines that are linked in the
graph and for cosines that are not.
.SS "write_histogram_matlab"
.IX Subsection "write_histogram_matlab"
write_histogram_matlab($linked_histogram_reference, \f(CW$not_linked_histogram_reference\fR, \f(CW$filename_base\fR)
.PP
Writes matlab files for linked, linked cumulative, and not linked
histograms based on the histogram distributions given.
.SS "get_histograms_as_string"
.IX Subsection "get_histograms_as_string"
get_histograms_as_string($linked_histogram_reference, \f(CW$not_linked_histogram_reference\fR)
.PP
Returns the histograms as a human-readable string that can be displayed
or saved to a file
.SS "create_cosine_dat_files"
.IX Subsection "create_cosine_dat_files"
create_cosine_dat_files($domain, \f(CW$cosine_matrix_reference\fR, directory => \f(CW$directory\fR)
.PP
Creates dat files with information from the cosine matrix, based on
randomly selected cosines
.SS "get_dat_stats"
.IX Subsection "get_dat_stats"
get_dat_stats($domain, \f(CW$links_file\fR, \f(CW$cosine_file\fR)
.PP
Returns a string with statistics obtained from the analyzing the dat
files created by create_cosine_dat_files
.SS "get_undirected_graph"
.IX Subsection "get_undirected_graph"
get_undirected_graph($graph)
.PP
Takes a graph and returns its undirected equivalent.  This maintains the weight
on each edge and vertex.
.SS "mmr_rerank_lexrank"
.IX Subsection "mmr_rerank_lexrank"
mmr_rerank_lexrank($lambda)
.PP
Reranks the lexrank scores using maximal marginal relevance. The parameter
\&\f(CW$lambda\fR should be in [0,1]. \f(CW$lambda\fR = 1 implies that the score will be
unchanged. \f(CW$lambda\fR = 0 will make the scores the negative of their similarity
with the first sentence. After calling mmr_rerank_lexrank, the scores
will be scaled so the highest score is 1 and the lowest score is 0. This
method should only be called after lexrank has been computed.
.SS "compute_pagerank"
.IX Subsection "compute_pagerank"
compute_pagerank(pagerank_value => 'pagerank_value', pagerank_transition => 'pagerank_transition',
pagerank_bias => 'pagerank_bias', jump => 0.15, tolerance => 0.0001, max_iterations => 200)
.PP
Computes the pagerank for the network.  The property given for pagerank_value is used for the
initial value, and for pagerank_transition for the transition probabilities.  The pagerank_bias
property is used to set the bias.  If the network does not have any values for that property
(or they are all zero) then the unbiased pagerank is computed.
.PP
All parameters are optional, the defaults for the properties are given.  Passing zero for any
numerical parameter (or not specifying that parameter) will cause the default value to be used.
.PP
The result is saved as the pagerank_value property of each node.
.SS "compute_stationary_distribution"
.IX Subsection "compute_stationary_distribution"
compute_stationary_distribution
.PP
Computes the stationary distribution from a random walk.  This uses the values from the
probability distribution and the transition probabilities.
.SS "create_cluster_from_lexrank"
.IX Subsection "create_cluster_from_lexrank"
create_cluster_from_lexrank($threshold, attribute_name => 'document', parent_document => 0)
.PP
Creates a cluster with any documents that currently have a lexrank value above the threshold.
The optional attribute_name parameter specifies what attribute of the node contains the
document.  'document', the default, is the attribute that will be used if the network
was created from a cluster.  Setting the optional parent_document parameter to 1 will
create the cluster out of the parent document of each document, rather than the document
itself.
.SS "create_network_from_lexrank"
.IX Subsection "create_network_from_lexrank"
create_network_from_lexrank
.PP
Creates a network with any nodes that currently have a lexrank value above the threshold.
.SS "create_subset_network"
.IX Subsection "create_subset_network"
create_subset_network($@subset_vertices);
.PP
Creates a network with just the nodes in the array provided as the first parameter.  Edges
from the original network are carried across to the network if they are between two
nodes that are in the new network.
.SS "create_subset_network_from_file"
.IX Subsection "create_subset_network_from_file"
create_subset_network_from_file($filename)
.PP
Creates a network with just the nodes listed in the file, one per each line.  Edges from
the original network are carried across to the new network if they are between two
nodes that are in the new network.
.SS "get_current_probability_distribution"
.IX Subsection "get_current_probability_distribution"
get_current_probability_distribution
.PP
Returns a hash with the current probability values (the values used for the random walk)
.SS "get_edge_attribute"
.IX Subsection "get_edge_attribute"
get_edge_attribute($u, \f(CW$v\fR, \f(CW$attribute_name\fR)
.PP
Returns the value of the attribute on the given edge
.SS "get_edge_weight"
.IX Subsection "get_edge_weight"
get_edge_weight($u, \f(CW$v\fR)
.PP
Returns the weight of the given edge.
.SS "get_edges"
.IX Subsection "get_edges"
get_edges
.PP
Returns the edges of the network
.SS "get_vertex_attribute"
.IX Subsection "get_vertex_attribute"
get_vertex_attribute($u, \f(CW$attribute_name\fR)
.PP
Returns the value of the attribute on the given vertex
.SS "get_vertices"
.IX Subsection "get_vertices"
get_vertices
.PP
Returns the array of vertices (nodes) in the network
.SS "has_edge"
.IX Subsection "has_edge"
has_edge($u, \f(CW$v\fR)
.PP
Returns true if an edge exists in the network, false otherwise
.SS "has_edge_attribute"
.IX Subsection "has_edge_attribute"
has_edge_attribute($u, \f(CW$v\fR, \f(CW$attribute_name\fR)
.PP
Returns true if the attribute has been set on the given edge and false otherwise.
.SS "has_node"
.IX Subsection "has_node"
has_node($u)
.PP
Returns true if the node is in the network
.SS "has_vertex_attribute"
.IX Subsection "has_vertex_attribute"
has_vertex_attribute($u, \f(CW$attribute_name\fR)
.PP
Returns true if the attribute has been set on the given vertex and false otherwise.
.SS "num_nodes"
.IX Subsection "num_nodes"
num_nodes
.PP
Returns the number of nodes in the network
.SS "print_current_lexrank_distribution"
.IX Subsection "print_current_lexrank_distribution"
print_current_lexrank_distribution
.PP
Prints the current lexrank values.  If the lexrank has been calculated, these are the
results, otherwise this may be the initial or intermediate values.
.SS "print_current_pagerank_distribution"
.IX Subsection "print_current_pagerank_distribution"
print_current_pagerank_distribution
.PP
Prints the current pagerank values.  If the pagerank has been calculated, these are the
results, otherwise this may be the initial or intermediate values.
.SS "print_hyperlink_edges"
.IX Subsection "print_hyperlink_edges"
print_hyperlink_edges
.PP
Prints all edges with the 'pagerank_transition' property set.  In the case of networks
built from hyperlinks from clusters, these edges are the edges that had a hyperlink
between them.
.PP
The edges are listed as source, then destination.
.SS "print_current_probability_distribution"
.IX Subsection "print_current_probability_distribution"
print_current_probability_distribution
.PP
Prints the current probability values from the random walk.  If the stationary distribution
has been calculated, these are the results, otherwise these may be the initial or
intermediate values
.SS "read_initial_probability_distribution"
.IX Subsection "read_initial_probability_distribution"
read_initial_probability_distribution($filename)
.PP
Reads the initial probabilities for the random walk from the specified file.
.SS "read_pagerank_initial_distribution"
.IX Subsection "read_pagerank_initial_distribution"
read_pagerank_initial_distribution($filename)
.PP
Reads the initial pagerank values from the specified file
.SS "read_pagerank_personalization"
.IX Subsection "read_pagerank_personalization"
read_pagerank_personalization($filename)
.PP
Reads the pagerank personalization values (bias) from the specified file
.SS "read_pagerank_probabilities_from_file"
.IX Subsection "read_pagerank_probabilities_from_file"
read_pagerank_probabilities_from_file($filename)
.PP
Read the pagerank transition probabilities from the specified file
.SS "save_current_pagerank_distribution"
.IX Subsection "save_current_pagerank_distribution"
save_current_pagerank_distribution($filename)
.PP
Saves the current pagerank values to a file.  If pagerank has been calculated, then these
are the results, otherwise these could be initial or intermediate values.
.SS "save_hyperlink_edges_to_file"
.IX Subsection "save_hyperlink_edges_to_file"
save_hyperlink_edges_to_file($filename)
.PP
Saves all edges with the 'pagerank_transition' property set to the specified file.
In the case of networks built from hyperlinks from clusters, these edges are the
edges that had a hyperlink between them.
.PP
The edges are listed as source, then destination.
.SS "save_pagerank_probabilities_to_file"
.IX Subsection "save_pagerank_probabilities_to_file"
save_pagerank_probabilities_to_file
.PP
Saves the transition probabilities used in pagerank to the specified file.
.SS "set_edge_attribute"
.IX Subsection "set_edge_attribute"
set_edge_attribute($u, \f(CW$v\fR, \f(CW$attribute_name\fR, \f(CW$value\fR)
.PP
Sets the attribute for the given edge to the given value
.SS "set_edge_weight"
.IX Subsection "set_edge_weight"
set_edge_weight($u, \f(CW$v\fR, \f(CW$weight\fR)
.PP
Sets the weight of the given edge.
.SS "set_vertex_attribute"
.IX Subsection "set_vertex_attribute"
set_vertex_attribute($u, \f(CW$attribute_name\fR, \f(CW$value\fR)
.PP
Sets the attribute for the vertex to the given value
.SS "get_predecessor_matrix"
.IX Subsection "get_predecessor_matrix"
\&\f(CW$matrix\fR = \fIget_predecessor_matrix()\fR
.PP
Get the shortest path matrix from the network, using \s-1BFS\s0 algorithm.
.PP
The content of the matrix is the predecessor of the current node in the shortest path matrix.
.PP
e.g. : \f(CW$matrix\fR\->{$i}\->{$j} notes the predecessor of node \f(CW$j\fR in the shortest path from \f(CW$i\fR to \f(CW$j\fR
.PP
to get the shortest path from \f(CW$i\fR to \f(CW$j\fR, you can use function get_shortest_path
.SS "get_shortest_path"
.IX Subsection "get_shortest_path"
\&\f(CW$path\fR = get_shortest_path($start, \f(CW$end\fR)
.PP
Get the shortest path from \f(CW$start\fR to \f(CW$end\fR.
.SS "func"
.IX Subsection "func"
func
.SS "func"
.IX Subsection "func"
func
.SH "AUTHOR"
.IX Header "AUTHOR"
Hodges, Mark << <clair at umich.edu> >>
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to
\&\f(CW\*(C`bug\-clair\-document at rt.cpan.org\*(C'\fR, or through the web interface at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=clairlib\-dev <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=clairlib-dev>.
I will be notified, and then you will automatically be notified of progress on
your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc Clair::Network
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
http://annocpan.org/dist/clairlib\-dev <http://annocpan.org/dist/clairlib-dev>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
http://cpanratings.perl.org/d/clairlib\-dev <http://cpanratings.perl.org/d/clairlib-dev>
.IP "\(bu" 4
\&\s-1RT:\s0 \s-1CPAN\s0's request tracker
.Sp
http://rt.cpan.org/NoAuth/Bugs.html?Dist=clairlib\-dev <http://rt.cpan.org/NoAuth/Bugs.html?Dist=clairlib-dev>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
http://search.cpan.org/dist/clairlib\-dev <http://search.cpan.org/dist/clairlib-dev>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright 2006 The University of Michigan, all rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.SS "add_weighted_edge"
.IX Subsection "add_weighted_edge"
add_weighted_edge($id1, \f(CW$id2\fR, \f(CW$w\fR);
.PP
Creates an edge between the two vertices specified.  If a vertex is
not already part of the graph, it is automatically added.
.SS "harmonic_mean_geodesic_distance"
.IX Subsection "harmonic_mean_geodesic_distance"
Compute the harmonic mean geodesic distance
.SS "Watts_Strogatz_local_clus_coeff"
.IX Subsection "Watts_Strogatz_local_clus_coeff"
Get the local clustering coefficient for each vertex
.PP
This is only defined for vertices with > 2 edges
.SS "Number of find_largest_component_size"
.IX Subsection "Number of find_largest_component_size"
Find size of largest component
.SS "find_components"
.IX Subsection "find_components"
find_components($type)
.PP
Return s list of components in the graph.
Type refers to the type of components and is either \*(L"weakly\*(R" or \*(L"strongly\*(R"
.SS "get_cumulative_distribution"
.IX Subsection "get_cumulative_distribution"
get_cumulative_distribution(\e%histogram)
.PP
Convert a histogram to cumulative distribution
.SS "save_network_to_file"
.IX Subsection "save_network_to_file"
save_network_to_file($filename)
.PP
Save network to a file, including edge weights if they are defined.
.SS "output_graphviz"
.IX Subsection "output_graphviz"
output_graphviz($filename)
.PP
Output GraphViz compatible file
To generate postscript:
dot \-Tps filename.dot > filename.ps
.SS "print_network_info"
.IX Subsection "print_network_info"
\&\fIprint_network_info()\fR
.PP
Prints various statistics about the network
.SS "compute_adjacency_matrix"
.IX Subsection "compute_adjacency_matrix"
Compute the adjacency matrix and store it.
This is used by several functions to speed up computations.
The Perl Graph library has slow accessors for nodes/edges if node/edge
properties are used.
.SS "get_shortest_path_matrix"
.IX Subsection "get_shortest_path_matrix"
Get the shortest path matrix, computing it if necessary
.SS "compute_asp_matrix"
.IX Subsection "compute_asp_matrix"
Compute the average shortest path matrix.  This is used by several functions.
.SS "print_asp_matrix"
.IX Subsection "print_asp_matrix"
Print the average shortest path matrix
.SS "find_all_shortest_paths"
.IX Subsection "find_all_shortest_paths"
Find all pairs of shortest paths
.SS "find_shortest_paths"
.IX Subsection "find_shortest_paths"
Find all shortest paths between two nodes
.SS "_find_shortest_paths"
.IX Subsection "_find_shortest_paths"
Helper method for find_shortest_paths
.SS "find_path_counts"
.IX Subsection "find_path_counts"
Find all shortest paths, then find the vertex counts in each.
.SS "get_network_info_as_string"
.IX Subsection "get_network_info_as_string"
\&\fIget_network_info_as_string()\fR
.PP
Print one line space-seperated summary of network info.
Useful when printing statistics on many networks, subnets, or similar.
.PP
Below is a list of the columns returned
.PP
nodes number of nodes in the network
edges number of edges in the network
diameter diameter of the network
lcc size of the largest connected component
avg_short_path average shortest path
ferrer_avg_short_path Ferrer i Cancho average shortest path
watts_strogatz_cc Watts-Strogatz clustering coefficient
newman_cc Newman clustering coefficient
in_link_power In-link power-law exponent (calculated from regression)
in_link_power_rsquared In-link power-law rsquared value
in_link_pscore In-link power-law p\-score (< 0.005 means fit)
in_link_power_newman In-link power-law exponent Newman formula
in_link_power_newman_error In-link power-law exponent Newman statistical error
out_link_power Out-link power-law exponent (calculated from regression)
out_link_power_rsquared Out-link power-law rsquared value
out_link_pscore Out-link power-law p\-score (< 0.005 means fit)
out_link_power_newman Out-link power-law exponent Newman formula
out_link_power_newman_error Out-link power-law exponent Newman statistical error
total_link_power Total-link power-law exponent (calculated from regression)
total_link_power_rsquared Total-link power-law rsquared value
total_link_pscore Total-link power-law p\-score (< 0.005 means fit)
total_link_power_newman Total-link power-law exponent Newman formula
total_link_power_newman_error Total-link power-law exponent Newman statistical error
avg_degree average degree
.SS "cumulative_power_law_exponent"
.IX Subsection "cumulative_power_law_exponent"
cumulative_power_law_exponent(\e%histogram)
.PP
Calculate the power law exponent from the cumulative distribution
.SS "get_p_score"
.IX Subsection "get_p_score"
Calculate the p score
\&\s-1TODO:\s0 Move this into the statistics package
.SS "newman_clustering_coefficient"
.IX Subsection "newman_clustering_coefficient"
\&\fInewman_clustering_coefficient()\fR
.PP
Calculate the Newman clustering coefficient of a graph.
Uses formula 3 in Newman's \*(L"Structure and Function of Complex Networks\*(R"
.SS "get_triangles"
.IX Subsection "get_triangles"
\&\fIget_triangles()\fR
.PP
Return all of the triangles in the network
.SS "create_network_from_cosines"
.IX Subsection "create_network_from_cosines"
create_network_from_cosines($threshold)
.PP
Return a new network with with edges >= threshold
.SS "create_cosine_network"
.IX Subsection "create_cosine_network"
create_cosine_network(\e@edges)
.PP
Create a network with nodes being documents and edge weights cosine values
for the documents.
.SS "\fIimport_from_pajek()\fP"
.IX Subsection "import_from_pajek()"
import_from_pajek($filename)
.PP
Create a network from a pajek .net file.
Example:   \f(CW$network\fR = Clair::Network\->import_from_pajek($filename);
.SS "import_network"
.IX Subsection "import_network"
import_network($filename)
.PP
Load in a network from a file.  File should be in edge edge format or
edge edge weight.
Parameters:
delim is the edge delimiter used in the file
sample is used to take a uniform random sample of the edges
directed and undirected indicate whether the graph should be directed or
undirected.  The default is directed.
.SS "create_network_from_array"
.IX Subsection "create_network_from_array"
.SS "get_shortest_path_length"
.IX Subsection "get_shortest_path_length"
get_shortest_path_length($vertex1, \f(CW$vertex2\fR)
.PP
Return the length of the shortest path between two nodes.
.SS "get_shortest_paths_lengths"
.IX Subsection "get_shortest_paths_lengths"
get_shortest_paths_lengths($vertex)
.PP
Return the shortest paths between vertex1 and the rest of the graph.  This is
returned as a hash with the keys being vertices and the values the distance
to that vertex.
.SS "find_all_paths"
.IX Subsection "find_all_paths"
find all paths between all pairs of vertices
.SS "find_paths"
.IX Subsection "find_paths"
\&\f(CW@paths\fR = find_paths($v1, \f(CW$v2\fR)
.PP
Find all paths between \f(CW$v1\fR and \f(CW$v2\fR
.SS "_find_paths"
.IX Subsection "_find_paths"
Private helper method to find paths
.IP "degree" 4
.IX Item "degree"
degree($vertex)
.Sp
Return the degree of a vertex.  For undirected graphs, this is the total
degree.  For directed graphs this is in-degree minus out-degree.
.IP "in_degree" 4
.IX Item "in_degree"
in_degree($vertex)
.Sp
Return the indegree of a vertex
.IP "out_degree" 4
.IX Item "out_degree"
out_degree($vertex)
.Sp
Return the outdegree of a vertex
.IP "total_degree" 4
.IX Item "total_degree"
total_degree($vertex)
.Sp
Return the total degree of a vertex
.IP "degree_assortativity_coefficient" 4
.IX Item "degree_assortativity_coefficient"
Return the assortavity coefficient for mixing by vertex degree.
.Sp
Directed:
Newman, Mixing patterns in networks, eq. 26
.Sp
Undirected:
Newman, Assortative mixing in networks, eq. 4
.SS "clear_cache"
.IX Subsection "clear_cache"
Clear cached objects such as asp matrix
.SS "sort_edges"
.IX Subsection "sort_edges"
Cache a list of edges sorted by weight
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 6055:" 4
.IX Item "Around line 6055:"
\&'=item' outside of any '=over'
.IP "Around line 6175:" 4
.IX Item "Around line 6175:"
You forgot a '=back' before '=head2'
